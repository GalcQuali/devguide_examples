import datetime

import jsonpickle
import requests
import isodate
import sys
from requests.auth import AuthBase
import time


class QualiTokenAuth(AuthBase):
    """Simple BASIC HTTP Auth implementation for the Sandbox API."""

    def __init__(self, token):
        self.token = token

    def __eq__(self, other):
        return all([
            self.token == getattr(other, 'token', None),
        ])

    def __ne__(self, other):
        return not self == other

    def __call__(self, r):
        # We only set the received token generated by the server as the Auth header
        r.headers['Authorization'] = 'Basic ' + self.token
        return r


class SandboxStates:
    """Sandbox possible states"""

    def __init__(self):
        pass

    PENDING_SETUP_STATE = 'Pending Setup'
    IN_SETUP_STATE = 'Setup'
    AFTER_SETUP_STATE = 'Ready'
    IN_TEARDOWN_STATE = 'Teardown'
    TEARDOWN_COMPLETE_STATE = 'Ended'


class SandboxRESTAPI:
    def __init__(self, hostname, api_port):
        self.hostname = hostname
        self.api_port = api_port
        self.token_auth = None


    @staticmethod
    def python_version_compatible_response_text(response):
        if sys.version_info >= (3, 0):
            return response.text
        else:
            return response.content


    def login(self, user, password, domain):
        login = requests.put('http://{hostname}:{api_port}/api/login'
                             .format(hostname=self.hostname, api_port=self.api_port),
                             json={'username': self._in_quotes(user),
                                   'password': self._in_quotes(password),
                                   'domain': self._in_quotes(domain)})

        self._ensure_response_success(login)

        response_text = self.python_version_compatible_response_text(login)
        token = self._without_quotes(response_text)

        self.token_auth = QualiTokenAuth(token)

    def start_sandbox(self, blueprint_identifier, time_delta, sandbox_name):
        """
        :param str blueprint_identifier: name or id
        :param datetime.timedelta time_delta: the sandbox duration
        :param str sandbox_name:
        :return str: The sandbox id
        """
        url = 'http://{hostname}:{api_port}/api/v1/blueprints/{blueprint_identifier}/start' \
            .format(hostname=self.hostname, api_port=self.api_port, blueprint_identifier=blueprint_identifier)

        duration = isodate.duration_isoformat(time_delta)

        response = requests.post(url, json={
            "duration": "{duration}".format(duration=duration),
            "name": "{name}".format(name=sandbox_name)
        }, auth=self.token_auth)

        self._ensure_response_success(response)

        response_text = self.python_version_compatible_response_text(response)

        return jsonpickle.loads(response_text)['id']

    def stop_sandbox(self, sandbox_id):
        """
        :param str sandbox_id:
        :return: None
        """
        url = 'http://{hostname}:{api_port}/api/v1/sandboxes/{sandbox_id}/stop' \
            .format(hostname=self.hostname, api_port=self.api_port, sandbox_id=sandbox_id)

        response = requests.post(url, auth=self.token_auth)

        self._ensure_response_success(response)

    def wait_for_sandbox_setup(self, sandbox_id):
        """
        Blocks until sandbox setup concludes successfully raises error otherwise
        :param str sandbox_id: Sandbox id
        :return: The post setup sandbox description
        """
        return self._wait_for_sandbox_state(sandbox_id, SandboxStates.AFTER_SETUP_STATE,
                                     [SandboxStates.PENDING_SETUP_STATE,
                                      SandboxStates.IN_SETUP_STATE], 10)

    def wait_for_sandbox_teardown(self, sandbox_id):
        """
        Blocks until sandbox teardown concludes successfully raises error otherwise
        :param str sandbox_id: Sandbox id
        :return: The post teardown sandbox description
        """
        return self._wait_for_sandbox_state(sandbox_id, SandboxStates.TEARDOWN_COMPLETE_STATE,
                                     [SandboxStates.IN_TEARDOWN_STATE,
                                      SandboxStates.AFTER_SETUP_STATE], 10)

    # <editor-fold desc="Private functions and helpers">
    def _get_sandbox_details(self, sandbox_id):
        url = 'http://{hostname}:{api_port}/api/v1/sandboxes/{sandbox_id}' \
            .format(hostname=self.hostname, api_port=self.api_port, sandbox_id=sandbox_id)
        response = requests.get(url, auth=self.token_auth)
        self._ensure_response_success(response)
        response_text = self.python_version_compatible_response_text(response)

        state = jsonpickle.loads(response_text)
        return state

    @staticmethod
    def _in_quotes(string):
        return "{string}".format(string=string)

    @staticmethod
    def _without_quotes(string):
        if string.endswith('"') and string.startswith('"'):
            return string[1:-1]

    def _ensure_logged_in(self):
        if not self.token_auth:
            raise Exception("Please use the login function to log in first")

    def _wait_for_sandbox_state(self, sandbox_id, target_state, allowed_transition_states, polling_frequency):
        """
        Generic function to poll until a target sandbox state is reached
        :param str sandbox_id: Sandbox Id to check
        :param str target_state: The end-state after which this blocking function will return
        :param list[str] allowed_transition_states: These transition states are valid, other states will throw an error
        :param int polling_frequency: number of seconds to wait between each polling attempt
        :return: Will return when target state is reached
        """
        sandbox_details = self._get_sandbox_details(sandbox_id)
        while not sandbox_details['state'] == target_state:
            if sandbox_details['state'] not in allowed_transition_states:
                raise Exception('Sandbox setup error or unknown state: {state}'.format(state=sandbox_details['state']))
            time.sleep(polling_frequency)
            sandbox_details = self._get_sandbox_details(sandbox_id)
        return sandbox_details


    @staticmethod
    def _ensure_response_success(response):
        if not response.status_code == 200:
            raise Exception("Could not start sandbox: {text}".format(text=response.text.encode('ascii')))
    # </editor-fold>

